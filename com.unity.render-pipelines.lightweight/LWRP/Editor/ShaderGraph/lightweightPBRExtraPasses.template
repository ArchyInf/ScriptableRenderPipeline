Pass
{
	Name "ShadowCaster"
    Tags{"LightMode" = "ShadowCaster"}

    ZWrite On ZTest LEqual

    // Material options generated by graph
${Culling}
    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles
    #pragma exclude_renderers d3d11_9x
    #pragma target 2.0

    //--------------------------------------
    // GPU Instancing
    #pragma multi_compile_instancing

    #pragma vertex ShadowPassVertex
    #pragma fragment ShadowPassFragment

    // Defines generated by graph
${Defines}
    #include "LWRP/ShaderLibrary/Core.hlsl"
    #include "LWRP/ShaderLibrary/Lighting.hlsl"
    #include "LWRP/ShaderLibrary/ShaderGraphFunctions.hlsl"
    #include "CoreRP/ShaderLibrary/Color.hlsl"

${Graph}
	struct VertexOutput
	{
	    float2 uv           : TEXCOORD0;
	    float4 clipPos      : SV_POSITION;
        // Interpolators defined by graph
${VertexOutputStruct}
        UNITY_VERTEX_INPUT_INSTANCE_ID
        UNITY_VERTEX_OUTPUT_STEREO
	};

    // x: global clip space bias, y: normal world space bias
    float4 _ShadowBias;
    float3 _LightDirection;

    VertexOutput ShadowPassVertex(GraphVertexInput v)
	{
	    VertexOutput o;
	    UNITY_SETUP_INSTANCE_ID(v);
        UNITY_TRANSFER_INSTANCE_ID(v, o);
        UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        // Vertex transformations performed by graph
${VertexShader}
		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        // Vertex description inputs defined by graph
${VertexShaderDescriptionInputs}
	    VertexDescription vd = PopulateVertexData(vdi);
        v.vertex.xyz = vd.Position;

	    // Vertex shader outputs defined by graph
${VertexShaderOutputs}
	    
	    float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
        float3 normalWS = TransformObjectToWorldDir(v.normal);

        float invNdotL = 1.0 - saturate(dot(_LightDirection, normalWS));
        float scale = invNdotL * _ShadowBias.y;

        // normal bias is negative since we want to apply an inset normal offset
        positionWS = normalWS * scale.xxx + positionWS;
        float4 clipPos = TransformWorldToHClip(positionWS);

        // _ShadowBias.x sign depens on if platform has reversed z buffer
        clipPos.z += _ShadowBias.x;

	#if UNITY_REVERSED_Z
	    clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
	#else
	    clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
	#endif
        o.clipPos = clipPos;

	    return o;
	}

    half4 ShadowPassFragment(VertexOutput IN) : SV_TARGET
    {
        UNITY_SETUP_INSTANCE_ID(IN);

        // Pixel transformations performed by graph
${PixelShader}
        SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
${PixelShaderSurfaceInputs}
        SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Emission = 0;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
${PixelShaderSurfaceRemap}
 #if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
        return 0;
    }

    ENDHLSL
}

Pass
{
	Name "DepthOnly"
    Tags{"LightMode" = "DepthOnly"}

    ZWrite On
    ColorMask 0

    // Material options generated by graph
${Culling}
    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles
    #pragma exclude_renderers d3d11_9x
    #pragma target 2.0

    //--------------------------------------
    // GPU Instancing
    #pragma multi_compile_instancing

    #pragma vertex vert
    #pragma fragment frag

    // Defines generated by graph
${Defines}
    #include "LWRP/ShaderLibrary/Core.hlsl"
    #include "LWRP/ShaderLibrary/Lighting.hlsl"
    #include "LWRP/ShaderLibrary/ShaderGraphFunctions.hlsl"
    #include "CoreRP/ShaderLibrary/Color.hlsl"

${Graph}
	struct VertexOutput
	{
	    float2 uv           : TEXCOORD0;
	    float4 clipPos      : SV_POSITION;
        // Interpolators defined by graph
${VertexOutputStruct}
        UNITY_VERTEX_INPUT_INSTANCE_ID
        UNITY_VERTEX_OUTPUT_STEREO
	};

    VertexOutput vert(GraphVertexInput v)
    {
        VertexOutput o = (VertexOutput)0;
	    UNITY_SETUP_INSTANCE_ID(v);
        UNITY_TRANSFER_INSTANCE_ID(v, o);
        UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	    // Vertex transformations performed by graph
${VertexShader}
		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        // Vertex description inputs defined by graph
${VertexShaderDescriptionInputs}
	    VertexDescription vd = PopulateVertexData(vdi);
        v.vertex.xyz = vd.Position;

	    // Vertex shader outputs defined by graph
${VertexShaderOutputs}
	    o.clipPos = TransformObjectToHClip(v.vertex.xyz);
	    return o;
    }

    half4 frag(VertexOutput IN) : SV_TARGET
    {
        UNITY_SETUP_INSTANCE_ID(IN);

        // Pixel transformations performed by graph
${PixelShader}
        SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
${PixelShaderSurfaceInputs}
        SurfaceDescription surf = PopulateSurfaceData(surfaceInput);
        
        float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Emission = 0;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
${PixelShaderSurfaceRemap}
 #if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
        return 0;
    }
    ENDHLSL
}

// This pass it not used during regular rendering, only for lightmap baking.
Pass
{
	Name "Meta"
    Tags{"LightMode" = "Meta"}

    Cull Off

    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles
    #pragma exclude_renderers d3d11_9x
    #pragma target 2.0

    #pragma vertex vert
    #pragma fragment frag

    // Defines generated by graph
${Defines}
    #include "LWRP/ShaderLibrary/Core.hlsl"
    #include "LWRP/ShaderLibrary/Lighting.hlsl"
    #include "LWRP/ShaderLibrary/ShaderGraphFunctions.hlsl"
    #include "CoreRP/ShaderLibrary/Color.hlsl"

    #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
    #pragma shader_feature EDITOR_VISUALIZATION

    CBUFFER_START(UnityMetaPass)
    // x = use uv1 as raster position
    // y = use uv2 as raster position
    bool4 unity_MetaVertexControl;

    // x = return albedo
    // y = return normal
    bool4 unity_MetaFragmentControl;
    CBUFFER_END

    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;

    ${Graph}
	struct VertexOutput
	{
	    float2 uv           : TEXCOORD0;
	    float4 clipPos      : SV_POSITION;
        // Interpolators defined by graph
${VertexOutputStruct}
        UNITY_VERTEX_INPUT_INSTANCE_ID
        UNITY_VERTEX_OUTPUT_STEREO
	};

    VertexOutput vert(GraphVertexInput v)
    {
        VertexOutput o = (VertexOutput)0;
	    UNITY_SETUP_INSTANCE_ID(v);
        UNITY_TRANSFER_INSTANCE_ID(v, o);
        UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

	    // Vertex transformations performed by graph
${VertexShader}

	    // Vertex shader outputs defined by graph
${VertexShaderOutputs}
        if (unity_MetaVertexControl.x)
        {
            v.vertex.xy = uv1 * unity_LightmapST.xy + unity_LightmapST.zw;
            // OpenGL right now needs to actually use incoming vertex position,
            // so use it in a very dummy way
            v.vertex.z = v.vertex.z > 0 ? REAL_MIN : 0.0f;
        }
	    o.clipPos = TransformWorldToHClip(v.vertex.xyz);
	    return o;
    }

    half4 frag(VertexOutput IN) : SV_TARGET
    {
        UNITY_SETUP_INSTANCE_ID(IN);

        // Pixel transformations performed by graph
${PixelShader}
        SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

		// Surface description inputs defined by graph
${PixelShaderSurfaceInputs}
        SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

		float3 Albedo = float3(0.5, 0.5, 0.5);
		float3 Emission = 0;
		float Alpha = 1;
		float AlphaClipThreshold = 0;

		// Surface description remap performed by graph
${PixelShaderSurfaceRemap}
 #if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
        
        half4 res = 0;
        if (unity_MetaFragmentControl.x)
        {
            res = half4(Albedo, 1);

            // d3d9 shader compiler doesn't like NaNs and infinity.
            unity_OneOverOutputBoost = saturate(unity_OneOverOutputBoost);

            // Apply Albedo Boost from LightmapSettings.
            res.rgb = clamp(PositivePow(res.rgb, unity_OneOverOutputBoost), 0, unity_MaxOutputValue);
        }
        if (unity_MetaFragmentControl.y)
        {
            res = half4(Emission, 1.0);
        }
        return res;
    }
    ENDHLSL
}